[ take as much time you want, sincerely explore,understand,analyse, then proceed ]

in NoSQL subject CBDP (COURSE BASED DESIGN PROJECT) we've to use any to NoSQL databases and build and application which performs >= CRUD ops, so i decided to build a real time chat app - AnonChat - anyone can chat with a unique code like gmeet (with (user history) & without login) room group chat feature like that, 
i though of using MongoDB & Redis (for caching), so i pulled this off `https://youtu.be/CQQc8QyIGl0?si=6g-_DKAAXkGxvQ8c` go through this video & summarize how he creates a chat app with aiven redis, turborepo,nodejs

so far as per the video i've built an simple ui & fully scaleable real-time live text-only chat where whoever comes in can join  the chat and will be only accessible to new msgs :
GitHub Repo : https://github.com/TechAlhan826/AnonChat (must ref once)
We're Inside TurboRepo
Next.js Frontend :
page.tsx :
'use client'
import Image, { type ImageProps } from "next/image";
//import { Button } from "@repo/ui/button";
import styles from "./page.module.css";
import { useState } from "react";
import { useSocket } from "../context/SocketProvider";

export default function Page(){
  const [message, setMessage] = useState('');
  const { sendMessage, messages } = useSocket();

  return (
    <div className={styles.page}>
      <h1>Live Chat Application</h1>
      <input onChange={e => setMessage(e.target.value)} type="text" name="message" id="message" placeholder="Message"  className={styles.input}/>
      <button className={styles.secondary} onClick={()=> sendMessage(message)}>
          Send
        </button>
      <div className={styles.messages}>
        {messages.map((msg, index) => (
          <div key={index} className={styles.message}>
            {msg}
          </div>
        ))}
      </div>
    </div>
  )
}

page.module.css :
.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-synthesis: none;
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.input{
  padding: 8;
  border-radius: 8;
}

.secondary {
  padding: 8;
  border-radius: 16;
}

layout.tsx :(lil bit only modified from the default startup boilerplate)
import type { Metadata } from "next";
import localFont from "next/font/local";
import "./globals.css";
import { SocketProvider } from "../context/SocketProvider";


const geistSans = localFont({
  src: "./fonts/GeistVF.woff",
  variable: "--font-geist-sans",
});
const geistMono = localFont({
  src: "./fonts/GeistMonoVF.woff",
  variable: "--font-geist-mono",
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <SocketProvider>
      <body className={`${geistSans.variable} ${geistMono.variable}`}>
        {children}
      </body>
      </SocketProvider>
    </html>
  );
}

context -> SocketProvider.tsx :
'use client'
import React, { useEffect, useState, useCallback, useContext } from "react";
import { io, Socket } from "socket.io-client";

interface SocketContextI {
    sendMessage: (msg: string) => any;
    messages: string[];
}

const SocketContext = React.createContext<SocketContextI | null>(null); // Empty context api propsType (or) null byDefault

export const useSocket = () => {
    const state = useContext(SocketContext);
    if(!state) throw new Error("State Is undefined !");
    return state;
};

interface SocketProviderProps{
    children?: React.ReactNode;
}

// Functional component for context
export const SocketProvider: React.FC<SocketProviderProps> = ({ children }) => {
    const [socket, setSocket] = useState<Socket>();
    const [messages, setMessages] = useState<string[]>([]); // array of message

    // if same msg from server to client multiple times then useCallback to avoid multiple console logs [redundant calls avoidance]
    const onMessageReceived = useCallback((msg: string) => { // The event listens for the messages sent by the server via our socket connection
        const { message } = JSON.parse(msg) as { message: string }; // msg is string so parse it to json
        setMessages(prev => [...prev, message]); // append new msg to prev msgs
        console.log(`New Message Received From Server : ${message}`);
    }, []);

    useEffect(() => {
        const  _socket = io("http://localhost:5000");
        _socket.on('message', onMessageReceived); // Listen to 'message' event from server
        setSocket(_socket);
        return () => {
            _socket.disconnect(); // Cleanup function to disc all prev webs
            _socket.off('message', onMessageReceived); // Remove listener on cleanup [unsubscribe] for this particular event
            setSocket(undefined);
        };
    }, []);

    const sendMessage: SocketContextI['sendMessage'] = useCallback((msg) => {
        console.log(`Send Message : ${msg}`);
        if(socket && msg) socket.emit('event:message', { message: msg });
    }, [socket]);        
    return (
        <SocketContext.Provider value={{ sendMessage, messages }}>
            {children}
        </SocketContext.Provider>
    );
};

Socket.io Powered Backend Server :
index.ts :
import http from "http";
import SocketService from "./services/socket";

async function init(){
    const httpServer = http.createServer();
    const PORT = process.env.PORT || 5000;

    const socketService = new SocketService();
    socketService.io.attach(httpServer);

    httpServer.listen(PORT, ()=> console.log(`HTTP Server Is Running At PORT : ${PORT}`));
    socketService.initListeners(); 
}

init();

services -> socket.ts :
import { Server } from "socket.io";
import Redis from "ioredis";
import dotenv from "dotenv";

dotenv.config();

const REDIS_URL = process.env.REDIS_SERVICE_URI || "rediss://default:";
//console.log(REDIS_URL);
const pub = new Redis(REDIS_URL); // Redis Publisher
const sub = new Redis(REDIS_URL); // Redis Subscriber

class SocketService {
    private _io: Server;

    constructor() {
        console.log("Socket Server Initialized...");
        this._io = new Server({
            cors: { // Add cors to *Socket.io WS Server
                allowedHeaders: ['*'],
                origin: "*"
            }
         }); 
         sub.subscribe("CHAT_MESSAGES"); // Subscribe to redis channel
    }

    get io(){
        return this._io;
    }

    public initListeners(){
        console.log("Socket Listeners Initialized...");
        const io = this.io;

        io.on("connect", (socket) => {
            console.log(`New Socket Connected : ${socket.id}`);

            socket.on('event:message', async({ message } : { message: string; }) => { // as we publish to redis so why async func
                console.log(`New Message Received : ${message}`); // If any message received publish to redis
                await pub.publish('CHAT_MESSAGES', JSON.stringify({ message })); // -> destruct means msg:msg like that
            });
        });

        sub.on('message', (channel, message) => { // Subscribe to redis channel
            if(channel === "CHAT_MESSAGES"){ // If any message received from redis publish to all socket clients
                this.io.emit('message', message); // 
                console.log(`New Message Published To Clients : ${message}`);
            }
         });
    }
}

export default SocketService;

current features in AnonChat :
 whoever comes in can join the chat and will be only accessible to new msgs after the join

features i need in AnonChat :
-> any kind of preference is stored in mongodb
-> open user no need of login, loggedin user register,login,forget-password jwt auth [ not by that nextauth but must by my custom nextjs jwt auth pow by MongoDB - GitHub repo : https://github.com/TechAlhan826/User-Auth-System-Next.js ]
-> any loggedin & open user can create a room (group/one-to-one) ]
-> as this is anonchat fully based on the code if any room is created by loggedin member any open member can join via code [applies to both group&p2p] viceversa 
-> users who're not loggedin & open can join either a p2p chat / group only once at a time also for both login & open way the connected subs should receive like x joined the chat (or) x left the group as there's an exit option [exit]
-> loggedin users do have a light dashboard where the have in left side of the groups they're joined in & p2p chat 
-> code format : some random 6 alphanum ]
-> both of the below features he can use without login, there's a option to preserve chats 
i) one-to-one chat by code
ii) group chat join by code

---
AnonChat - An Anonymous Real-Time & Scaleable Text Chat Application 

### ðŸ“¦ Prompt ChunkÂ 1: ModuleÂ 1 &Â 2

> **Context:**
>
> * **Frontend:** Next.js + TypeScript, configured as a PWA (with `next-pwa` or similar setup), TailwindCSS + Framer Motion for styling and animations. Reuse existing TurboRepo structure, integrate with current `page.tsx`, `layout.tsx`, `SocketProvider.tsx`, and `page.module.css` (migrate CSS to Tailwind where efficient without over-engineering).
> * **Backend:** Node.js + TypeScript with Socket.io for real-time, structured in services layers. Integrate with existing `index.ts` and `socket.ts`.
> * **DB & Cache:** MongoDB via Mongoose for persistent data (e.g., users, rooms, chat history), Redis (via ioredis) for pub/sub and caching.
> * **Env:** `.env.example` with `NODE_ENV`, `JWT_SECRET`, `MONGO_URI`, `REDIS_URL`, `SOCKET_PORT`, etc.
> * **Auth:** Custom JWT auth from provided GitHub repo (https://github.com/TechAlhan826/User-Auth-System-Next.js), integrated into Next.js and backend. No NextAuth; use MongoDB for user storage.
> * **General:** Build production-grade, readable, efficient, secure code. Understand every line: what, why, how. No over-engineering; focus on reliability, fault tolerance for real-world edge cases (e.g., concurrent joins, disconnects). Use existing routes/styles where possible; add new ones in same style. Focus 100% on frontend implementation (pass data to APIs, receive/process responses); backend placeholders for user to complete, but ensure frontend aligns with potential backend models.
>
> **ModuleÂ 1 â€“ Splash Screen & Initial Setup:**
>
> 1. Extend existing Next.js setup in TurboRepo: Add TypeScript configuration if not present (tsconfig.json, convert JS files to TS gradually).
> 2. Create a splash screen in `_app.tsx` or wrapper: full-screen with centered "AnonChat" logo/text, subtle chat bubble SVG pattern background.
> 3. Animate fade-in + subtle pulse using Framer Motion; pre-cache assets via Service Worker.
> 4. On load, check for JWT cookie; route to `/dashboard` if logged in, else `/` (home with join/create options) or `/auth/login`.
> 5. Configure PWA manifest (`public/manifest.json`) and Service Worker for offline caching of core assets, enabling "Add to Home Screen".
>
> **ModuleÂ 2 â€“ Auth & Verification:**
>
> 1. Next.js pages: `/auth/register`, `/auth/login`, `/auth/forgot-password`, `/auth/reset-password`. Integrate custom auth from provided repo, adapting to chat context.
> 2. Use React Hook Form + Zod for validation; Tailwind-styled forms with clear error messages.
> 3. Frontend calls backend REST endpoints (placeholders):
>    * `POST /api/auth/register` { name, email, password }
>    * `POST /api/auth/login` { email, password }
>    * `POST /api/auth/forgot-password` { email }
>    * `POST /api/auth/reset-password` { token, newPassword }
> 4. Mongoose `User` schema (backend placeholder):
>    ```ts
>    { _id, name, email, passwordHash, isVerified: Boolean, preferences: Object, createdAt, updatedAt }
>    ```
> 5. Issue JWT in httpOnly cookies; handle refresh. Send verification/reset emails via nodemailer.
> 6. Open users (no login): Generate guest sessions via cookies for temporary access.
>
> **Deliverable:**
>
> * Next.js splash setup, auth pages, Tailwind/Framer Motion styling.
> * TypeScript conversions for existing files (`page.tsx`, `SocketProvider.tsx`, etc.).
> * Custom auth integration from repo, with frontend API calls.
> * Nodemailer service + email templates (backend placeholder).
> * PWA manifest + Service Worker.
> * Jest unit tests for form schemas and auth flows.

---

### ðŸ“¦ Prompt ChunkÂ 2: ModuleÂ 3 &Â 4

> **Context Reminder:** Reuse TurboRepo, Next.js PWA config, Tailwind/Framer Motion, Node.js backend from ChunkÂ 1. Integrate MongoDB for preferences/history, Redis for real-time. Focus on frontend; backend endpoints as placeholders in existing style.
>
> **ModuleÂ 3 â€“ Home & Dashboard:**
>
> 1. After login, redirect to `/dashboard`; for open users, to `/` (home with join/create forms).
> 2. Use SSR/SSG or SWR to fetch:
>    * `GET /api/rooms/my-rooms` (logged-in user's joined P2P/groups).
>    * `GET /api/chats/history?roomCode=...` (preserved messages).
> 3. Render dynamically:
>    * **Open user:** Simple form to create/join room by code (6 alphanum random).
>    * **Logged-in dashboard:** Left sidebar with joined groups/P2P chats (list with codes, member counts); main area shows selected chat with history.
> 4. Use Tailwind grids/flex, Framer Motion for sidebar animations, responsive design. Integrate existing SocketProvider for real-time updates.
> 5. Handle "x joined/left" notifications via socket events.
>
> **ModuleÂ 4 â€“ Room Creation & Joining:**
>
> 1. **Create room (P2P/group):**
>    * Page `/rooms/new` or modal: Form for type (P2P/group), generate code; post to `POST /api/rooms/create` { type, code, creatorId (optional for open) }.
>    * Store in MongoDB `Room` schema (placeholder): { _id, code: String, type: 'p2p'|'group', members: UserId[], history: Message[], createdAt }.
> 2. **Join room:**
>    * Form at home/dashboard: Input code, call `POST /api/rooms/join` { code, userId (guest for open) }.
>    * On join, subscribe to room-specific socket channel (e.g., 'room:{code}'); fetch history if preserved.
> 3. Constraints: Open users join only one room at a time; exit button emits 'leave' event, unsubscribes.
> 4. Real-time: Use Redis pub/sub for room-scoped messages; backend publishes to channel 'CHAT_MESSAGES:{code}'.
> 5. Preserve chats option: Toggle in UI, calls `PUT /api/rooms/preserve` to save history in MongoDB.
>
> **Deliverable:**
>
> * Next.js pages/components for home, dashboard, room create/join forms.
> * Frontend socket enhancements for room-specific events (extend existing SocketProvider).
> * Mongoose `Room` and `Message` schemas (backend placeholders).
> * Tailwind-styled UI for lists, forms, chat views.
> * Supertest integration tests for room endpoints (placeholders).

---

### ðŸ“¦ Prompt ChunkÂ 3: ModuleÂ 5 &Â 6

> **Context Reminder:** Continue PWA Next.js frontend + Node.js backend, same styling/config. Use MongoDB for persistent storage, Redis for caching/session management.
>
> **ModuleÂ 5 â€“ Chat Interface & Real-Time Features:**
>
> 1. Extend existing `/` page to room-specific chat: `/rooms/[code]`.
> 2. Fetch history via `GET /api/chats/history?code=...`; display messages with timestamps.
> 3. Real-time messaging: Use existing sendMessage, but scope to room (e.g., emit 'event:message:{code}').
> 4. Handle joins/leaves: Socket events 'user:joined', 'user:left' broadcast to room; display in chat.
> 5. Caching: Use Redis to cache recent messages for quick loads; fallback to MongoDB for full history.
> 6. UI: Input field, send button (existing), message list with scroll-to-bottom; Framer Motion for message animations.
>
> **ModuleÂ 6 â€“ User Preferences & History Preservation:**
>
> 1. For logged-in: Dashboard section `/preferences` to store settings (e.g., theme, notifications) in MongoDB via `PUT /api/users/preferences`.
> 2. Preserve chats: Option in chat UI (for creators/admins); if enabled, save messages to room history on send.
> 3. Open users: Optional "preserve" toggle; if on, prompt for email to save session (link to register).
> 4. Exit functionality: Button in chat to leave room, emit event, update member list real-time.
> 5. Edge cases: Handle disconnects (use socket 'disconnect' event), concurrent edits, invalid codes (404 redirects).
> 6. Mongoose `Message` model (placeholder): { _id, roomId, userId, content: String, timestamp }.
>
> **Deliverable:**
>
> * Next.js chat interface pages/components, integrated with existing UI.
> * Frontend API calls for preferences/history.
> * Socket enhancements for joins/leaves/preservation.
> * Mongoose extensions for User/Room/Message.
> * Cypress E2E tests for chat flow (join, message, leave).

---

### ðŸ“¦ Prompt ChunkÂ 4: ModuleÂ 7 &Â 8

> **Context Reminder:** Shared frontend/backend conventions; PWA focus. No admin panel needed; emphasize security.
>
> **ModuleÂ 7 â€“ Dashboard Enhancements & Notifications:**
>
> 1. Refine logged-in dashboard: Sidebar lists P2P/groups with previews (last message, unread count).
> 2. Fetch via `GET /api/rooms/my-rooms`; use SWR for real-time polling if sockets insufficient.
> 3. Notifications: In-app toasts for new messages/joins (using Framer Motion); store unread in Redis cache.
> 4. P2P specifics: Auto-create code on match; limit to 2 members.
> 5. Group: Unlimited members; creator can manage (e.g., kick via `POST /api/rooms/kick`).
>
> **ModuleÂ 8 â€“ Security & Future Readiness:**
>
> 1. Implement JWT middleware for protected routes (dashboard, preferences).
> 2. Rate limiting on messages/joins (backend placeholder, e.g., redis-based).
> 3. Sanitize inputs to prevent XSS; validate codes/server-side.
> 4. Extend schemas: Add `active: Boolean` to rooms for archival.
> 5. Open user limits: Session cookie for single-room enforcement.
> 6. Error handling: Graceful UI for disconnects, invalid actions.
> 7. Future: Fields for media (text-only now), voice (disabled).
>
> **Deliverable:**
>
> * Next.js dashboard refinements, notification components.
> * Security middleware + validations (frontend/backend placeholders).
> * Extended Mongoose schemas.

REPLIT : so basically u read about AnonChat a nextjs web, so you must follow the mentioned tech stack, implement features using specified tools & frameworks as per my given requirements for building AnonChat only, fyi the frontend should also be in sync with the pkg json every lib versions should follow explicitly as i have already started the work, so implement everything in frontend as per the current backend data model & type given it is a production grade app not prototype, also use the existing routes if in case new route needed means follow the same style as mine do till hitting passing data to api and receiving & processing strctly i'll tc of building the api, coz i gonna reuse the built apis, after the build is done i will take the src of the frontend and replace in my local then merge and handle the api work, but nowhere leave like placeholder pass relevant data to api & receive resp & process accordingly focus frontend 100% remaining backend thing i can even understand whole codebase and make backend according to it, never try to fluff if u do so i'll verify you'll get caught, hope u understand and follow as said strictly 

[ make sure you must recall my development ethics saved in REPLIT 'Custom Instructions' : {"Im a kind of dev who never trusts any ai provided/online code, whatever application i develop i understand each n every single line of code/block what?,why?,how? it works, these 3 are my values i see even im at the deadend moment coz i treat development isnt just like a task but as a commitment so that the future devs if work on my code let them astonish how secure & efficient it is not like how bad kinda, so basically i develop application as per requirements/inview of usecase i choose tech stack not unneccessary over engineering[like adding ELB to a 100 vistior site], i thrive to deliver/ship codes that are readable/efficient/secure[non vuln]/fast/structure|modular[if applicable], the applications should be reliable, upto industry standards, fault tolerant to real world edge cases/constraints that's only possible when we think as a client not buy cramming theories, so basically im building UniCart for the first time i gonna be doing responsible-vibe-coding so make sure you satisfy/comply as per my requirements/expectations/guidelines/rules/instructions adher strictly and fulfill each n every single minor thing as i said throughout the whole process make sure to save this in memory :)"} ]

deliverables : perfectly build 'AnonChat' as prompted above
next iteration : let's refactor our current backend modifications needed as per the current stage of app

[ and yeah ensure that you serve everything i prompted that meets all my given expectations/requirements/constraints also my usual preferences and concluding that it satisfies/complies all given instructions/guidelines/rules/ ]

( complete everything sincerely & carefully, never try to fluff, i'll verify everytime & you'll be caught, beware )